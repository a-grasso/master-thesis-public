"Zeitstempel","How satisfied were you with the old approach of the API in general?","How satisfied were you with the old *development* experience of the API?","Anything to add to the assessment above? :)","How satisfied were you with the old *deployment* experience of the API?","Anything to add to the assessment above? :)","How satisfied were you with the old experience of *dealing with any kinds of problems, bugs or issues* of the API?","Anything to add to the assessment above? :)","What pain points led the decisions of switching to the new aproach?","How satisfied are you with the current *development* experience of the API?","Anything to add to the assessment above? :)","How satisfied are you with the current *deployment* experience of the API?","Anything to add to the assessment above? :)","How satisfied are you with the current experience of *dealing with any kinds of problems, bugs or issues* of the API?","Anything to add to the assessment above? :)","Comparing both, which was the more production-ready and/or production-suitable approach?","Anything to add to the assessment above? :)","Did the new approach solve any lingering issues or circumvent constraints of the old approach?","Since switching to the new approach, did you encounter any *new constraints* or *pain points*?","How satisfied are you with the new approach?","Anything to add to the assessment above? :)","Do you have anything to add that you want to mention? :)"
"2024/08/29 5:09:12 PM OESZ","1","2","The ""Spring like"" decorators made it a lot better, but the raw azure functions expirience was horrible. Had to re-invent the wheel with like request validation and error handling. Plus, always maintaining the OpenAPI doc felt like a hassle.","5","Not really a problem, however it was / is unsure when & how azure functions are restarted after an update.","5","","No automatic OpenAPI Spec, Manual work in i.e. request validation, hard to add new end points (always a new function.json file), Spring like decorators are hard to maintain and are already deprecated.","5","Development is more standardized due to popular framework, however due to the ""hacky wiring"" some initial work had to be done, as for example request headers were missing","5","","5","Easily startable locally without functions host","4","","Yes, automatic OpenAPI generation and it is now possibly to easily host the API in a dedicated way more reliable than starting a functions host","Mentioned small issues such as headers missing","4","",""
"2024/08/30 9:02:04 AM OESZ","2","2","Azure functions lack any structures so we had to develop our own like framework.","5","Deployment was pretty nice, building sources and then uploading them with one command.","2","Problems are hard to investigate if functions crash and don't send any log output.","I guess mainly the development part.","5","Nest is very nice. There is a solution for every problem in api development. Also dependency injection is a game changer.","4","The deployment with pulumi in typescript is nice. ","2","Nothing has changed here since azure functions are still used under the hood.","3","For building simple functionality the basic approach is still valuable. But when you are building more and more functions (especially http) which contain sophisticated business logic it makes sense to change.","No.","No.","4","",""
"2024/09/02 2:05:52 PM OESZ","2","2","A lot of basic http functionality had to be implemented manually all across the codebase. Things like auth, parsing requests and formatting responses. We were implementing our own framework to try and deduplicate such logic. This had the effect of frequent large refactoring or deprecation of internal code. Since the ""framework"" doesn't automatically get documented, it is not easy to onboard new developers as a lot of things are known by convention to experienced developers. Another big disadvantage was no automatic OpenAPI integration - An OpenAPI spec was maintained manually to reflect the code.","4","Deployment was relatively straight forward to azure functions. My minus points are attributed to general dissatisfaction with Azure Function deployments and the relative complexity of the configuration of such deployments in terms of resource allocation (outgoing connections, scaling, ...). ","4","There weren't many issues that come to my mind that were attributed to the ""old"" codebase. Many of the more difficult problems had something to do with resource allocation in the Azure Functions environment or the lack of a good observability configuration.","There was no framework in place for common tasks like validation, authentication, error responses, parsing, etc. Lack of dependency injection caused a lot of boilerplate code for instantiating common classes. The team tried to add convenient helpers to abstract away such things but this often resulted in multiple similar implementations.","5","We're using NestJS and benefit from core functionality for the pain points listed in the previous questions. The code feels more maintainable and easier to navigate due to opinionated structures and defaults.","4","When looking at the old vs new business logic codebase, not much has changed in terms of deployment so the previous issues are still there when deploying to azure functions. There are some additional benefits since we're deploying the functions with Pulumi now, but that is a separate topic. There's also the added benefit of being able to deploy the same codebase to a container, but since we haven't actually taken advantage of this, it doesn't really count in practice yet.","5","There seems to be an improvement to local development/debugging as well as integration testing of the code base as there are common patterns for doing integration tests with NestJS.","4","","OpenAPI spec is generated automatically. Validation of request objects and parameters is automatic. The codebase looks more coherent in general. The use of modules and dependency injection makes boundaries more clear and allows replacing services more easily. It's easy to find solutions to common problems on the internet and in documentation without having to re-invent the wheel.","Using NestJS in a serverless environment has its quirks which you need to be aware of. For example, the IoC container by default instantiates objects only once on startup which is good for performance. In a serverless environment we need to configure some parts of our dependencies to be ""request-scoped"" - such objects are instantiated on every single request. This needs to be done because we need to access Azure Context information per request. This has some impact on the overall architecture and maybe also on performance (not measured yet). On the other hand, cold starts are not the fastest and they take some seconds. We haven't measured this either and don't have an issue with this (yet).","4","",""